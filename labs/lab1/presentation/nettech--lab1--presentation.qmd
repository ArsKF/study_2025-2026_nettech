---
## Author
author:
  name: Арсений Валерьевич Агаев
  email: 1032221668@rudn.ru
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 6
## Title
title: Лабораторная работа №1
subtitle: Методы кодирования и модуляции сигналов
license: CC BY
date: today
date-format: "YYYY-MM-DD" # Example: 2025-09-06
---

# Информация

## Докладчик

:::::::::::::: {.columns align=center}
::: {.column width="70%"}

  * Арсений Валерьевич Агаев
  * студент
  * Российский университет дружбы народов им. П. Лумумбы
  * [1032221668@rudn.ru](mailto:1032221668@rudn.ru)

:::
::: {.column width="30%"}

:::
::::::::::::::

# Цели и задачи

- Изучение методов кодирования и модуляции сигналов с помощью высокоуровнего языка программирования Octave.
- Определение спектра и параметров сигнала.
- Демонстрация принципов модуляции сигнала на примере аналоговой
амплитудной модуляции.
- Исследование свойства самосинхронизации сигнала.

# Содержание исследования

## Построение графиков в Octave. Построение графика

```
x=-10:0.1:10;
y1=sin(x)+1/3*sin(3*x)+1/5*sin(5*x);

plot(x, y1, "-ok; y1=sin(x)+(1/3)*sin(3*x)+(1/5)*sin(5*x);", "markersize", 4);
grid on;
xlabel('x');
ylabel('y');
title('y1=sin(x) + (1/3)sin(3x) + (1/5)sin(5x)');
print("plot-sin.eps", "-mono", "-FArial:16", "-deps");
print("plot-sin.png");
```

## Построение графиков в Octave. Результат

![График функции y1=sin(x)+(1/3)*sin(3*x)+(1/5)*sin(5*x)](image/plot-sin.png){#fig-001 width=70%}

## Построение графиков в Octave. Построение нескольких графиков

```
x=-10:0.1:10;
y1=sin(x)+1/3*sin(3*x)+1/5*sin(5*x);
y2=cos(x)+1/3*cos(3*x)+1/5*cos(5*x);

hold on;
plot(x, y1, "-ok; y1=sin(x)+(1/3)*sin(3*x)+(1/5)*sin(5*x);", "markersize", 4);
plot(x, y2, "k; y2=cos(x)+(1/3)*cos(3*x)+(1/5)*cos(5*x);", "markersize", 4);
hold off;

grid on;
xlabel('x');
ylabel('y');
title('y1-y2');
print("plot-sin-cos.eps", "-mono", "-FArial:16", "-deps");
print("plot-sin-cos.png");
```
## Построение графиков в Octave. Результат

![График функций](image/plot-sin-cos.png){#fig-002 width=70%}

## Разложение импульсного сигнала в частичный ряд Фурье

```
N=8;
t=-1:0.01:1;
A=1;
T=1;

nh=(1:N)*2-1;
Am=2/pi ./ nh;
Am(2:2:end) = -Am(2:2:end);

harmonics=cos(2 * pi * nh' * t/T);
s1=harmonics.*repmat(Am',1,length(t));

s2=cumsum(s1);
for k=1:N
  subplot(4,2,k);
  plot(t, s2(k,:));
end

print("plot_meandr.png")
```

## Разложение импульсного сигнала в частичный ряд Фурье. Результат

![График функций меандра (косинусы)](image/plot_meandr.png){#fig-003 width=70%}

## Разложение импульсного сигнала в частичный ряд Фурье через синусы

![График функций меандра (синусы)](image/plot_meandr_sin.png){#fig-004 width=70%}

## Определение спектра и параметров сигнала. Объявление значений

```
mkdir 'signal';
mkdir 'spectre';

tmax = 0.5;
fd = 512;
f1 = 10;
f2 = 40;
a1 = 1;
a2 = 0.7;
t = 0:1./fd:tmax;
fd2 = fd/2;

signal1 = a1*sin(2*pi*t*f1);
signal2 = a2*sin(2*pi*t*f2);
```

## Определение спектра и параметров сигнала. График сигналов

```
plot(signal1, 'b');

hold on;
plot(signal2, 'r');
hold off;

title('Signal');

print('signal/spectre.png');
```

## Определение спектра и параметров сигнала. График сигналов. Результат

![Синусоидальные сигналы разной частоты](image/spectre1/signal/spectre.png){#fig-005 width=70%}

## Определение спектра и параметров сигнала. Спектры сигналов

```
spectre1 = abs(fft(signal1,fd));
spectre2 = abs(fft(signal2,fd));

plot(spectre1, 'b');
hold on;
plot(spectre2, 'r');
hold off;

title('Spectre');
print('spectre/spectre.png');
```

## Определение спектра и параметров сигнала. Спектры сигналов. Результат

![Спектры синусоидальных сигналов](image/spectre1/spectre/spectre.png){#fig-006 width=70%}

## Определение спектра и параметров сигнала. Корректировка

```
f = 1000 * (0:fd2)./(2*fd);

spectre1 = 2 * spectre1/fd2;
spectre2 = 2 * spectre2/fd2;

plot(f, spectre1(1:fd2+1), 'b');
hold on;
plot(f, spectre2(1:fd2+1), 'r');
hold off;

xlim([0 100]);
title('Fixed spectre');
xlabel('Frequency (Hz)');
print('spectre/spectre_fix.png');
```

## Определение спектра и параметров сигнала. Корректировка. Результат

![Исправленный график спектров синусоидальных сигналов](image/spectre1/spectre/spectre_fix.png){#fig-007 width=70%}

## Амплитудная модуляция

```
mkdir 'signal';
mkdir 'spectre';

tmax = 0.5;
fd = 512;
f1 = 5;
f2 = 50;
fd2 = fd/2;

t = 0:1./fd:tmax;
signal1 = sin(2*pi*t*f1);
signal2 = sin(2*pi*t*f2);
signal = signal1 .* signal2;
plot(signal, 'b');
hold on;
plot(signal1, 'r');
plot(-signal1, 'r');
hold off;
title('Signal');
print 'signal/am.png';

spectre = fft(signal,fd);

f = 1000*(0:fd2)./(2*fd);

spectre = 2*sqrt(spectre.*conj(spectre))./fd2;

plot(f,spectre(1:fd2+1), 'b');
xlim([0 100]);
title('Spectre');
xlabel('Frequency (Hz)');
print 'spectre/am.png';
```

## Амплитудная модуляция. Результат 1

![Сигнал и огибающая при амплитудной модуляции](image/modulation/signal/am.png){#fig-010 width=70%}

## Амплитудная модуляция. Результат 2

![Спектр сигнала при амплитудной модуляции](image/modulation/spectre/am.png){#fig-011 width=70%}

## Кодирование сигнала. Исследование свойства самосинхронизации сигнала. Входные данные

```
data=[0 1 0 0 1 1 0 0 0 1 1 0];
data_sync=[0 0 0 0 0 0 0 1 1 1 1 1 1 1];
data_spectre=[0 1 0 1 0 1 0 1 0 1 0 1 0 1];
```

## Кодирование сигнала. Исследование свойства самосинхронизации сигнала. Униполярная кодирование

```
function wave=unipolar(data)
  wave=maptowave(data);
```

## Кодирование сигнала. Исследование свойства самосинхронизации сигнала. Кодирование AMI

```
% Кодирование AMI:
function wave=ami(data)
  am=mod(1:length(data(data==1)),2);
  am(am==0)=-1;
  data(data==1)=am;
  wave=maptowave(data);
```

## Кодирование сигнала. Исследование свойства самосинхронизации сигнала. Кодирование NRZ

```
% Кодирование NRZ:
function wave=bipolarnrz(data)
  data(data==0)=-1;
  wave=maptowave(data);
```

## Кодирование сигнала. Исследование свойства самосинхронизации сигнала. Кодирование RZ

```
% Кодирование RZ:
function wave=bipolarrz(data)
  data(data==0)=-1;
  data=upsample(data,2);
  wave=maptowave(data);
```

## Кодирование сигнала. Исследование свойства самосинхронизации сигнала. Манчестерское кодирование 

```
% Манчестерское кодирование:
function wave=manchester(data)
  data(data==0)=-1;
  data=upsample(data,2);
  data=filter([-1 1],1,data);
  wave=maptowave(data);
```

## Кодирование сигнала. Исследование свойства самосинхронизации сигнала. Дифференциальное манчестерское кодирование

```
% Дифференциальное манчестерское кодирование
function wave=diffmanc(data)
  data=filter(1,[1 1],data);
  data=mod(data,2);
  wave=manchester(data);
```

## Кодирование сигнала. Сигнал. Униполярное кодирование

![Униполярное кодирование](image/coding/signal/unipolar.png){#fig-012 width=70%}

## Кодирование сигнала. Сигнал. Кодирование AMI

![Кодирование AMI](image/coding/signal/ami.png){#fig-013 width=70%}

## Кодирование сигнала. Сигнал. Кодирование NRZ

![Кодирование NRZ](image/coding/signal/bipolarnrz.png){#fig-014 width=70%}

## Кодирование сигнала. Сигнал. Кодирование RZ

![Кодирование RZ](image/coding/signal/bipolarrz.png){#fig-015 width=70%}

## Кодирование сигнала. Сигнал. МК

![Манчестерское кодирование](image/coding/signal/manchester.png){#fig-016 width=70%}

## Кодирование сигнала. Сигнал. ДМК

![Дифференциальное манчестерское кодирование](image/coding/signal/diffmanc.png){#fig-017 width=70%}

## Исследование свойства самосинхронизации сигнала. Униполярное кодирование

![Униполярное кодирование: нет самосинхронизации](image/coding/sync/unipolar.png){#fig-018 width=70%}

## Исследование свойства самосинхронизации сигнала. Кодирование AMI

![Кодирование AMI: самосинхронизация при наличии сигнала](image/coding/sync/ami.png){#fig-019 width=70%}

## Исследование свойства самосинхронизации сигнала. Кодирование NRZ

![Кодирование NRZ: нет самосинхронизации](image/coding/sync/bipolarnrz.png){#fig-020 width=70%}

## Исследование свойства самосинхронизации сигнала. Кодирование RZ

![Кодирование RZ: самосинхронизация](image/coding/sync/bipolarrz.png){#fig-021 width=70%}

## Исследование свойства самосинхронизации сигнала. МК

![Манчестерское кодирование: самосинхронизация](image/coding/sync/manchester.png){#fig-022 width=70%}

## Исследование свойства самосинхронизации сигнала. ДМК

![Дифференциальное манчестерское кодирование: самосинхронизация](image/coding/sync/diffmanc.png){#fig-023 width=70%}

## Кодирование сигнала. Спектр. Униполярное кодирование

![Униполярное кодирование: спектр сигнала](image/coding/spectre/unipolar.png){#fig-024 width=70%}

## Кодирование сигнала. Спектр. Кодирование AMI

![Кодирование AMI: спектр сигнала](image/coding/spectre/ami.png){#fig-025 width=70%}

## Кодирование сигнала. Спектр. Кодирование NRZ

![Кодирование NRZ: спектр сигнала](image/coding/spectre/bipolarnrz.png){#fig-026 width=70%}

## Кодирование сигнала. Спектр. Кодирование RZ

![Кодирование RZ: спектр сигнала](image/coding/spectre/bipolarrz.png){#fig-027 width=70%}

## Кодирование сигнала. Спектр. МК

![Манчестерское кодирование: спектр сигнала](image/coding/spectre/manchester.png){#fig-028 width=70%}

## Кодирование сигнала. Спектр. ДМК

![Дифференциальное манчестерское кодирование: спектр сигнала](image/coding/spectre/diffmanc.png){#fig-029 width=70%}

# Результаты

- Я изучил методы кодирования и модуляции сигналов с помощью высокоуровнего языка программирования Octave.
- Определил спектр и параметры сигнала.
- Продемонстрировал принципы модуляции сигнала на примере аналоговой
амплитудной модуляции.
- Исследовал свойства самосинхронизации сигнала.




